<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木木的小屋</title>
  
  <subtitle>活在当下</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-23T03:58:07.266Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杜文丽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>309. Best Time to Buy and Sell Stock with Cooldown</title>
    <link href="http://yoursite.com/2018/10/23/309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/"/>
    <id>http://yoursite.com/2018/10/23/309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/</id>
    <published>2018-10-23T03:51:42.000Z</published>
    <updated>2018-10-23T03:58:07.266Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution144</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当天 要么买 要么卖 要么停滞</span></span><br><span class="line"><span class="comment">     * 如果买 则获利为 i-2天卖了的利润 - 当天的买价</span></span><br><span class="line"><span class="comment">     * 如果卖 则获利为i-1天买了的利润 + 当天的卖价</span></span><br><span class="line"><span class="comment">     * 前提 必须在买了之后才能卖</span></span><br><span class="line"><span class="comment">     * 必须在卖了之后才能买</span></span><br><span class="line"><span class="comment">     * 所以二者交替进行操作</span></span><br><span class="line"><span class="comment">     * 初始化的时候 也就是第一天的时候 只能进行买操作，因而先初始化buy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=prices.size();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buy(len+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sell(len+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        buy[<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=len ; ++i) &#123;</span><br><span class="line">            sell[i]=max(sell[i<span class="number">-1</span>],buy[i<span class="number">-1</span>]+prices[i<span class="number">-1</span>]);</span><br><span class="line">            buy[i]=max(buy[i<span class="number">-1</span>],sell[i<span class="number">-2</span>]-prices[i<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sell[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>webGL lesson1</title>
    <link href="http://yoursite.com/2018/10/15/webGL-lesson1/"/>
    <id>http://yoursite.com/2018/10/15/webGL-lesson1/</id>
    <published>2018-10-15T11:32:03.000Z</published>
    <updated>2018-10-15T15:23:55.791Z</updated>
    
    <content type="html"><![CDATA[<p>我学习webGL的网址 <a href="http://www.hiwebgl.com/?p=42" target="_blank" rel="noopener">http://www.hiwebgl.com/?p=42</a></p><p>除了完成作业之外，更重要的是，欣欣是写网页的，莫名其妙也对网页感兴趣了，嘿嘿，开干！</p><p>canvas 绘制3D图形的，清空canvas的时候，启用深度检测（这样在后面的物体就会被前面的物体遮挡住gl.enable(gl.DEPTH_TEST)</p><p>对webGL的一些初始化函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function webGLStart() &#123;</span><br><span class="line">      var canvas = document.getElementById(&quot;lesson01-canvas&quot;);</span><br><span class="line">      initGL(canvas);</span><br><span class="line">      initShaders();</span><br><span class="line">      initBuffers();</span><br><span class="line"> </span><br><span class="line">      gl.clearColor(0.0, 0.0, 0.0, 1.0);</span><br><span class="line">      gl.enable(gl.DEPTH_TEST);</span><br><span class="line"> </span><br><span class="line">      drawScene();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我学习webGL的网址 &lt;a href=&quot;http://www.hiwebgl.com/?p=42&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.hiwebgl.com/?p=42&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了完成作业之外，更重要的是，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>reading notes of How To Read A Paper</title>
    <link href="http://yoursite.com/2018/10/12/reading-notes-of-How-To-Read-A-Paper/"/>
    <id>http://yoursite.com/2018/10/12/reading-notes-of-How-To-Read-A-Paper/</id>
    <published>2018-10-12T01:59:28.000Z</published>
    <updated>2018-10-12T02:31:00.245Z</updated>
    
    <content type="html"><![CDATA[<p>THREE-PASS</p><p>I.<em>first pass</em>: gives you a general idea about the paper.</p><ol><li>Carefully read the title, abstract, and introduction</li><li>Read the section and sub-section headings, but ignore everything else</li><li>Glance at the mathematical content (if any) to determine the underlying theoretical foundations</li><li>Read the conclusions</li><li><p>Glance over the references, mentally ticking oﬀ the ones you’ve already read</p><p><em>five Cs:</em></p></li><li><p>Category: What type of paper is this? A measurement paper? An analysis of an existing system? A description of a research prototype?</p></li><li>Context: Which other papers is it related to? Which theoretical bases were used to analyze the problem?</li><li>Correctness: Do the assumptions appear to be valid?</li><li>Contributions: What are the paper’s main contributions?</li><li>Clarity: Is the paper well written?</li></ol><p>II.<em>second pass</em> :  grasp the paper’s content,but not its details.</p><p> read the paper with greater care, but ignore details such as proofs,“note down terms you didn’t understand, or questions you may want to ask the author.” An hour.</p><ol><li>Look carefully at the ﬁgures, diagrams and other illustrations in the paper. Pay special attention to graphs. Are the axes properly labeled? Are results shown with error bars, so that conclusions are statistically signiﬁcant? Common mistakes like these will separate rushed, shoddy work from the truly excellent.</li><li>Remember to mark relevant unread references for further reading (this is a good way to learn more about the background of the paper).</li><li>don’t fully understand?  (a) set the paper aside, hoping you don’t need to understand the material to be successful in your career, (b) return to the paper later, perhaps after reading background material or (c) persevere and go on to the third pass. </li></ol><p>III.<em>third pass</em>:  understand the paper in depth.</p><p> virtually re-implement </p><p>What papers should you read? </p><p>1.use an academic search engine such as Google Scholar or CiteSeer and some well-chosen keywords to ﬁnd three to ﬁve recent highly-cited papers in the area.</p><p>2.ﬁnd shared citations and repeated author names in the bibliography.Download the key papers and set them aside. Then go to the websites of the key researchers and see where they’ve published recently. </p><p>3.go to the website for these top conferences and look through their recent proceedings. </p><p>RELATED WORK </p><p>If you are reading a paper to do a review, you should also read Timothy Roscoe’s paper on “Writing reviews for systems conferences” . </p><p>If you’re planning to write a technical paper, you should refer both to Henning Schulzrinne’s comprehensive web site and George Whitesides’s excellent overview of the process. </p><p>Finally, Simon Peyton Jones has a website that covers the entire spectrum of research skills. </p><p>OTHER REFERENCE</p><p><a href="http://www.cs.columbia.edu/∼hgs/etc/writing-style.html" target="_blank" rel="noopener">http://www.cs.columbia.edu/∼hgs/etc/writing-style.html</a></p><p><a href="http://people.inf.ethz.ch/troscoe/pubs/review-writing.pdf" target="_blank" rel="noopener">http://people.inf.ethz.ch/troscoe/pubs/review-writing.pdf</a></p><p><a href="http://www.ee.ucr.edu/∼rlake/Whitesides" target="_blank" rel="noopener">http://www.ee.ucr.edu/∼rlake/Whitesides</a> writing res paper.pdf</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;THREE-PASS&lt;/p&gt;
&lt;p&gt;I.&lt;em&gt;first pass&lt;/em&gt;: gives you a general idea about the paper.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Carefully read the title, abstract, and i
      
    
    </summary>
    
    
      <category term="paper" scheme="http://yoursite.com/tags/paper/"/>
    
  </entry>
  
  <entry>
    <title>cs float representation</title>
    <link href="http://yoursite.com/2018/10/08/cs-float-representation/"/>
    <id>http://yoursite.com/2018/10/08/cs-float-representation/</id>
    <published>2018-10-08T02:23:02.000Z</published>
    <updated>2018-10-08T02:47:22.668Z</updated>
    
    <content type="html"><![CDATA[<p><img src="C:\Users\18749\AppData\Local\Temp\1538965471498.png" alt="1538965471498"></p><p><img src="a.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;C:\Users\18749\AppData\Local\Temp\1538965471498.png&quot; alt=&quot;1538965471498&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;a.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="computer system" scheme="http://yoursite.com/tags/computer-system/"/>
    
  </entry>
  
  <entry>
    <title>动态规划 leetcode 72题edit distance</title>
    <link href="http://yoursite.com/2018/09/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-leetcode-72%E9%A2%98edit-distance/"/>
    <id>http://yoursite.com/2018/09/12/动态规划-leetcode-72题edit-distance/</id>
    <published>2018-09-12T09:33:28.000Z</published>
    <updated>2018-09-12T16:11:06.766Z</updated>
    
    <content type="html"><![CDATA[<p>一直分不清楚动态规划和贪心，今天好好啃一啃</p><p>贪心：Ai –&gt; Ai+1</p><p>动归：A0,A1,A2….Ai –&gt;Ai+1 判断问题的子结构，具有最优子结构时，动归适用</p><p>嘤 贪心的复杂度明显低于动归</p><p>在最长子序列中（不一定连续），贪心思路</p><p>最开始，缓冲区里为空；</p><p>看到了字符“1”，添加到缓冲区的最后，即缓冲区中是“1”；</p><p>看到了字符“4”，“4”比缓冲区的所有字符都大，因此将“4”添加到缓冲区的最后，得到“14”；</p><p>看到了字符“6”，“6”比缓冲区的所有字符都大，因此将“6”添加到缓冲区的最后，得到“146”；</p><p>看到了字符“2”，“2”比“1”大，比“4”小，因此将“4”直接替换成“2”，得到“126”；</p><p>看到了字符“8”，“8”比缓冲区的所有字符都大，因此将“8”添加到缓冲区的最后，得到“1268”；</p><p>看到了字符“9”，“9”比缓冲区的所有字符都大，因此将“9”添加到缓冲区的最后，得到“12689”；</p><p>看到了字符“7”，“7”比“6”大，比“8”小，因此将“8”直接替换成“7”，得到“12679”；</p><p>现在，缓冲区的字符数目为5，因此，数组A的LIS的长度就是5！</p><p>这样，时间复杂度变为每次都在一个递增的序列中替换或插入一个新的元素，所以为O(nlogn)。、</p><p>提问！但这种做法只能得到长度，并不能得到子序列本身 </p><p>但是为什么是对的呢？在一个大佬的帮助下 理解了 大佬的解释是：相等的上升子序列，最后一个元素越小，越有利于之后使上升子序列的长度增加。 精辟！ 而且反正替换的也是比这个数大的最小的数，如果下一个数比这个数大，也只会替换后面的数字 前面的也没什么影响</p><p>动归思路：从第一位开始到最后一位，依次计算所有递增序列的长度，保存，最后来做比较</p><p>总之就是要 <strong>降低问题的规模</strong>！！！</p><p>问题重述：Given two words <em>word1</em> and <em>word2</em>, find the minimum number of steps required to convert <em>word1</em> to <em>word2</em>. (each operation is counted as 1 step.)</p><p>You have the following 3 operations permitted on a word:</p><p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p><p>思路：</p><p>打表存储 和DNA测序一样的思路</p><p>贴代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution35 &#123;</span><br><span class="line">public:</span><br><span class="line">    int minDistance(string word1, string word2) &#123;</span><br><span class="line">        int len1=word1.length();</span><br><span class="line">        int len2=word2.length();</span><br><span class="line">        int dis[len1+1][len2+1];</span><br><span class="line">        //初始化数据</span><br><span class="line">        for (int k = 0; k &lt;len1+1 ; ++k) &#123;</span><br><span class="line">            for (int i = 0; i &lt;len2+1 ; ++i) &#123;</span><br><span class="line">                dis[k][i]=INT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt;len1+1 ; ++i) &#123;</span><br><span class="line">            dis[i][0]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt;len2+1 ; ++j) &#123;</span><br><span class="line">            dis[0][j]=j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //进行运算</span><br><span class="line">        for (int l = 1; l &lt;len1+1 ; ++l) &#123;</span><br><span class="line">            for (int i = 1; i &lt;len2+1 ; ++i) &#123;</span><br><span class="line">                if(word1[l-1]==word2[i-1])&#123;</span><br><span class="line">                    dis[l][i]=dis[l-1][i-1];</span><br><span class="line">                &#125; else</span><br><span class="line">                    dis[l][i]=min(dis[l-1][i-1],min(dis[l-1][i],dis[l][i-1]))+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dis[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直分不清楚动态规划和贪心，今天好好啃一啃&lt;/p&gt;
&lt;p&gt;贪心：Ai –&amp;gt; Ai+1&lt;/p&gt;
&lt;p&gt;动归：A0,A1,A2….Ai –&amp;gt;Ai+1 判断问题的子结构，具有最优子结构时，动归适用&lt;/p&gt;
&lt;p&gt;嘤 贪心的复杂度明显低于动归&lt;/p&gt;
&lt;p&gt;在最长子序列
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP</title>
    <link href="http://yoursite.com/2018/09/05/TCP-IP/"/>
    <id>http://yoursite.com/2018/09/05/TCP-IP/</id>
    <published>2018-09-05T13:13:51.000Z</published>
    <updated>2018-09-06T00:11:56.433Z</updated>
    
    <content type="html"><![CDATA[<p><strong>链路层</strong>：网络接口层，包含设备的网络接口卡。</p><p><strong>网络层</strong>：处理分组在网络中的活动，分组的选路。</p><p>IP : 负责对数据加上IP地址，确定传输目标</p><p>ICMP,IGMP</p><p><strong>运输层</strong>：TCP:（传输控制协议）把  可靠传输机制   代码封装成接口函数API，即socket。用TCP port辨别所服务的application protocol</p><p>UDP：（用户数据报协议）什么鸟事都不干，只用来辨别application protocol的。把数据报的分组从一台主机发送到另一台主机。</p><p><strong>应用层</strong>：Telnet远程登录、FTP文件传输协议、SMTP简单邮件传送协议，SNMP简单网络管理协议</p><p>ISP：为端系统提供了一系列网络访问的类型</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;链路层&lt;/strong&gt;：网络接口层，包含设备的网络接口卡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;：处理分组在网络中的活动，分组的选路。&lt;/p&gt;
&lt;p&gt;IP : 负责对数据加上IP地址，确定传输目标&lt;/p&gt;
&lt;p&gt;ICMP,IGMP&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TensorFlow图形生成、保存、查看</title>
    <link href="http://yoursite.com/2018/09/03/TensorFlow%E5%9B%BE%E5%BD%A2%E7%94%9F%E6%88%90%E3%80%81%E4%BF%9D%E5%AD%98%E3%80%81%E6%9F%A5%E7%9C%8B/"/>
    <id>http://yoursite.com/2018/09/03/TensorFlow图形生成、保存、查看/</id>
    <published>2018-09-03T02:44:21.000Z</published>
    <updated>2018-09-03T06:41:07.896Z</updated>
    
    <content type="html"><![CDATA[<p>首先定义保存路径</p><p>path = “./log”   #在项目中创建了一个叫log的文件夹</p><p>writer = tf.summary.FileWriter(path,sess.graph)</p><p>在当前项目文件夹下打开bash，运行代码  tensorboard –logdir=log</p><p>会在指定文件夹下生成如下文件</p><p><img src="a.png" alt=""></p><p>然后打开指定命令行下的网址就可以看到生成的图像。</p><p><img src="b.png" alt=""></p><p>简单代码参考：<a href="https://github.com/DuWenLi-mumu/tfPython/blob/master/tensorboard.py" target="_blank" rel="noopener">https://github.com/DuWenLi-mumu/tfPython/blob/master/tensorboard.py</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先定义保存路径&lt;/p&gt;
&lt;p&gt;path = “./log”   #在项目中创建了一个叫log的文件夹&lt;/p&gt;
&lt;p&gt;writer = tf.summary.FileWriter(path,sess.graph)&lt;/p&gt;
&lt;p&gt;在当前项目文件夹下打开bash，运行代码  t
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习，神经网络基础 --持续更新中</title>
    <link href="http://yoursite.com/2018/08/30/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    <id>http://yoursite.com/2018/08/30/神经网络基础-持续更新中/</id>
    <published>2018-08-30T13:18:41.000Z</published>
    <updated>2018-09-03T09:52:23.274Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习术语：<a href="https://developers.google.com/machine-learning/crash-course/framing/ml-terminology" target="_blank" rel="noopener">https://developers.google.com/machine-learning/crash-course/framing/ml-terminology</a></p><p>卷积神经网络的介绍：<a href="https://developers.google.com/machine-learning/practica/image-classification/convolutional-neural-networks" target="_blank" rel="noopener">https://developers.google.com/machine-learning/practica/image-classification/convolutional-neural-networks</a></p><p><strong><em>卷积的定义包含两个参数</em></strong></p><ul><li><strong>Size of the tiles that are extracted</strong> (typically 3x3 or 5x5 pixels).</li><li><strong>The depth of the output feature map</strong>, which corresponds to the number of filters that are applied.</li></ul><p><img src="f.png" alt=""></p><p><img src="g.png" alt=""></p><p>1.卷积的特征提取。</p><p>2.ReLU</p><p>3.Pooling</p><p>4.Fully Connected Layers</p><p><img src="h.png" alt=""></p><p>CNN: 卷积输入向量 通过卷积核进行一定的运算（也叫做滤波器）进行输入的特征提取。</p><p>池化层：不影响质量的前提下进行压缩，减少参数，有maxPooling,AveragePooling。</p><p>Zero Padding补零操作使输出尺寸不变。</p><p>做完池化层之后，数据拍平Flatten层，然后放到全连接层，方便交给分类器进行分类。。。</p><p>全连接层：高度提纯特征，把图像变成一个向量，例如最后一层池化之后，输出的图像是20个12x12，通过有100个20x12x12的卷积核的全连接层变成了1x100的向量，</p><p>平方损失（L2）损失</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">= the square of the difference between the label and the prediction</span><br><span class="line">= (observation - prediction(x))2</span><br><span class="line">= (y - y&apos;)2</span><br></pre></td></tr></table></figure><p><strong>均方误差</strong> (<strong>MSE</strong>) 指的是每个样本的平均平方损失。要计算 MSE，请求出各个样本的所有平方损失之和，然后除以样本数量：</p><p><img src="a.png" alt=""></p><p>其中</p><ul><li>x 指的是模型进行预测时使用的特征集（例如，温度、年龄和交配成功率）。</li><li><p>y 指的是样本的标签（例如，每分钟的鸣叫次数）。</p></li><li><p>prediction(x) 指的是权重和偏差与特征集 x 结合的函数。</p></li><li>D 指的是包含多个有标签样本（即 (x,y)）的数据集。</li><li>N 指的是 D 中的样本数量</li></ul><p>epoch：一个epoch指代所有的数据送入网络中完成一次前向计算及反向传播的过程</p><p>batch size ：所谓Batch就是每次送入网络中训练的一部分数据，而Batch Size就是每个batch中训练样本的数量</p><p>shuffle（洗牌）: 在做机器学习的任务时，需要在运行模型之前将特征转化成词id再转化成模型可识别的二进制文件形式，其中转化成的词id文件最好进行shuffle，打乱各行数据，这样参数能不易陷入局部最优，模型能够更容易达到收敛。</p><p>正则化：避免过拟合，wccccc好吧 吴恩达老师讲过，我又忘记了，嘤嘤嘤。在保持有所有特征的前提下，减少特征的权重，也就是λ。嘿嘿，在特征多的时候效果很好哦。</p><p>引入惩罚项。下面的min是需要优化的误差值</p><p><img src="b.jpg" alt=""></p><p><img src="c.jpg" alt=""></p><p><img src="b.png" alt=""></p><p><img src="c.jpg" alt=""></p><p><img src="d,jpg" alt=""></p><p><strong>正则化项</strong>（complexity），用于衡量模型复杂度</p><p>λ是正则化率。λ越大，权值越小，易出现欠拟合。λ越小，权值越大，易出现过拟合</p><p>嘤嘤嘤，我终于懂了，妈妈的，嘤嘤嘤</p><p>这篇博客的正则化讲的很详细了<a href="https://www.cnblogs.com/jianxinzhou/p/4083921.html" target="_blank" rel="noopener">https://www.cnblogs.com/jianxinzhou/p/4083921.html</a></p><p>妈的，老是记不住线性回归和逻辑回归</p><p>在此重申：</p><p>线性回归：按照权重和结点值加起来 连续，预测</p><p>逻辑回归：在线性回归基础上加了sigmod函数 分类问题，不连续</p><p><strong>范数</strong></p><p> L0范数是指向量中非0的元素的个数</p><p> L1范数是指向量中各个元素绝对值之和，也有个美称叫“稀疏规则算子”（Lasso regularization）。L1范数是L0范数的最优凸近似</p><p> L2范数是指向量各元素的平方和然后求平方根。我们让L2范数的规则项||W||2最小，可以使得W的每个元素都很小，都接近于0，但与L1范数不同，它不会让它等于0，而是接近于0，这里是有很大的区别的哦。而越小的参数说明模型越简单，越简单的模型则越不容易产生过拟合现象</p><p><strong>稀疏矩阵，稠密矩阵</strong>：在矩阵中，如果数值为0的元素数目远远多于非0元素的数目，并且非0元素分布无规律时，则称该矩阵为稀疏矩阵；与之相反，若非0元素数目占大多数时，则称该矩阵为稠密矩阵。</p><p><strong>“神经网络”的所有标准组件：</strong></p><ul><li>一组节点，类似于神经元，位于层中。</li><li>一组权重，表示每个神经网络层与其下方的层之间的关系。下方的层可能是另一个神经网络层，也可能是其他类型的层。</li><li>一组偏差，每个节点一个偏差。</li><li>一个激活函数，对层中每个节点的输出进行转换。不同的层可能拥有不同的激活函数。</li></ul><p>训练神经网络的最佳做法</p><p><a href="https://developers.google.com/machine-learning/crash-course/training-neural-networks/best-practices" target="_blank" rel="noopener">https://developers.google.com/machine-learning/crash-course/training-neural-networks/best-practices</a></p><p>卷积神经网络的理解</p><p><img src="d.jpg" alt=""></p><p>channel：厚度</p><p>下图是3 channel的</p><p><img src="i.png" alt=""></p><p>卷积核中的27个数字与分别与样本对应相乘后，再进行求和，得到第一个结果。依次进行，最终得到 4×4.由于只有一个卷积核，所以最终得到的结果为 4×4×1。</p><p>channel分类</p><ol><li>最初输入的图片样本的 <code>channels</code> ，取决于图片类型，比如RGB；</li><li>卷积操作完成后输出的 <code>out_channels</code> ，取决于卷积核的数量。此时的 <code>out_channels</code> 也会作为下一次卷积时的卷积核的 <code>in_channels</code>；</li><li>卷积核中的 <code>in_channels</code> ，刚刚2中已经说了，就是上一次卷积的 <code>out_channels</code> ，如果是第一次做卷积，就是1中样本图片的 <code>channels</code> 。</li></ol><p>filter：卷积核的数量</p><p>下图是两个filter</p><p><img src="j.png" alt=""></p><p>one_hot独热码，编码形式。encodeing<br>0,1,2,3,4,5,6,7,8,9 十位数字 用一种独特的形式表示<br>0:1000000000   1:0100000000  2:0010000000  以此类推</p><p>交叉熵：cross_entropy：另一种计算误差的方法，比二次代价函数<img src="k.png" alt="">计算误差要好。误差表达式：<img src="l.png" alt="">!,对w求偏导得到表达式<img src="m.jpg" alt="">误差越大，梯度就越大，参数w调整得越快，训练速度也就越快</p><p>adam优化器：原博客解释 <a href="https://www.cnblogs.com/xinchrome/p/4964930.html" target="_blank" rel="noopener">https://www.cnblogs.com/xinchrome/p/4964930.html</a> （讲的还行，勉强理解了）Adam 这个名字来源于 adaptive moment estimation，自适应矩估计。概率论中矩的含义是：如果一个随机变量 X 服从某个分布，X 的一阶矩是 E(X)，也就是样本平均值，X 的二阶矩就是 E(X^2)，也就是样本平方的平均值。</p><p>Adam 算法根据损失函数对每个参数的梯度的一阶矩估计和二阶矩估计动态调整针对于每个参数的学习速率。Adam 也是基于梯度下降的方法，但是每次迭代参数的学习步长都有一个确定的范围，不会因为很大的梯度导致很大的学习步长，参数的值比较稳定。it does not require stationary objective, works with sparse gradients, naturally performs a form of step size annealing。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;机器学习术语：&lt;a href=&quot;https://developers.google.com/machine-learning/crash-course/framing/ml-terminology&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
    
      <category term="神经网络" scheme="http://yoursite.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow解决overfitting</title>
    <link href="http://yoursite.com/2018/08/30/TensorFlow%E8%A7%A3%E5%86%B3overfitting/"/>
    <id>http://yoursite.com/2018/08/30/TensorFlow解决overfitting/</id>
    <published>2018-08-30T09:03:03.000Z</published>
    <updated>2018-08-30T09:28:01.781Z</updated>
    
    <content type="html"><![CDATA[<p>首先理解dropout</p><p>对于神经网络单元，按照一定比例的概率将其暂时从网络中丢弃。目的就是为了防止过拟合。</p><p>每次做完dropout，相当于从原始的网络中找到一个更瘦的网络。在每次训练的时候，让一半的特征检测器停止工作，提高网络的泛化能力。</p><p>在向前传导的时候，让某个神经元的激活值以一定的概率p让其停止工作</p><p><img src="a.png" alt=""></p><p>看了那么多，我好像只能看懂这些，等到以后看懂更多的时候再来补充吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先理解dropout&lt;/p&gt;
&lt;p&gt;对于神经网络单元，按照一定比例的概率将其暂时从网络中丢弃。目的就是为了防止过拟合。&lt;/p&gt;
&lt;p&gt;每次做完dropout，相当于从原始的网络中找到一个更瘦的网络。在每次训练的时候，让一半的特征检测器停止工作，提高网络的泛化能力。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="TensorFlow" scheme="http://yoursite.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow 基础</title>
    <link href="http://yoursite.com/2018/08/30/TensorFlow-%E5%BC%A0%E9%87%8F%EF%BC%8C%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2018/08/30/TensorFlow-张量，变量/</id>
    <published>2018-08-30T07:11:17.000Z</published>
    <updated>2018-09-03T09:52:26.317Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>参考资料：</em></strong></p><p>原博客链接：<a href="https://www.jianshu.com/p/d9ab35b56ab8" target="_blank" rel="noopener">https://www.jianshu.com/p/d9ab35b56ab8</a></p><p>TensorFlow.js官网api <a href="https://js.tensorflow.org/api" target="_blank" rel="noopener">https://js.tensorflow.org/api</a></p><p>python的参考文档：<a href="https://www.tensorflow.org/api_docs/python/tf" target="_blank" rel="noopener">https://www.tensorflow.org/api_docs/python/tf</a></p><p>TensorFlow.js例子<a href="https://js.tensorflow.org/tutorials/fit-curve.html" target="_blank" rel="noopener">https://js.tensorflow.org/tutorials/fit-curve.html</a></p><p>TensorFlow各种激活函数：<a href="https://www.tensorflow.org/api_guides/python/nn" target="_blank" rel="noopener">https://www.tensorflow.org/api_guides/python/nn</a></p><p>TensorFlow的游乐场 <a href="http://playground.tensorflow.org" target="_blank" rel="noopener">http://playground.tensorflow.org</a></p><p>python绘图matplotlib  <a href="https://matplotlib.org" target="_blank" rel="noopener">https://matplotlib.org</a></p><p><strong><em>TensorFlow程序的流程</em></strong></p><p>1.定义算法的<strong>计算图（graph）</strong>结构</p><p>2.使用<strong>会话（session）</strong>执行计算</p><p>TensorFlow中图：节点（operation），边：Tensor</p><p>会话：（session）运行静态图的某一个部分，启动图的一部分</p><p><img src="e.png" alt=""></p><p><strong><em>基础知识：</em></strong></p><p>每个TF都有一个默认的图</p><p>张量：值不可变tf.tensor</p><p>0阶张量为标量</p><p>1阶张量为向量</p><p>2阶张量为矩阵</p><p>3阶张量为体积（暂且这样说吧）</p><p><img src="a.png" alt=""></p><p>变量 ：tf.Variable  用一个张量值来初始化的，可用assign方法给一个存在的变量分配一个新张量，值可变。用于模型训练时候，数据的保存和更新.变量通常贯穿于机器学习模型的整个生命周期中，在 TensorFlow.js 中，即使是在 tf.tidy 里创建，js也不会清理它们；但是，你可以手动调用 dispose。</p><p>有了变量必须还要使用tf.initialize_all_variables()来初始化变量。</p><p><img src="b.png" alt=""></p><p>操作：operations(ops) 操作张量，返回新张量，原张量值不变</p><p>有square，add，sub等，支持嵌套操作</p><p><code>tf.tidy</code> 执行后就会清除所有中间新建的 tensors 来达到释放 GPU 内存，但不会消除内部的返回值。</p><p>模型和层：一个函数及一个模型，给定相应输入得到期望输出</p><p>tf.mode是一个模型，可以是线性模型，有了模型以后就可以往里面添加层</p><p>tf.sequential 一层的输入是下一层的输出，拓扑排序是线性的栈</p><p><img src="c.png" alt=""></p><p>tf.layers.dense 全连接层，添加一个层，即初学的add_layer()函数</p><p>dense(<br>    inputs,<br>    units,<br>    activation=None,<br>    use_bias=True,<br>    kernel_initializer=None,<br>    bias_initializer=tf.zeros_initializer(),<br>    kernel_regularizer=None,<br>    bias_regularizer=None,<br>    activity_regularizer=None,<br>    trainable=True,<br>    name=None,<br>    reuse=None<br>)</p><p>inputs: 输入数据，2维tensor. </p><p>units: 该层的神经单元结点数。</p><p>inputshape：[1,2,3]的shape是(3,);一个二阶的张量[[1,2,3],[4,5,6]]的shape是(2,3);一个三阶的张量[[[1],[2],[3]],[[4],[5],[6]]]的shape是(2,3,1)  </p><p>activation: 激活函数.</p><p>use_bias: Boolean型，是否使用偏置项.  </p><p>kernel_initializer: 卷积核的初始化器. </p><p>bias_initializer: 偏置项的初始化器，默认初始化为0. </p><p>kernel_regularizer: 卷积核化的正则化，可选. </p><p>bias_regularizer: 偏置项的正则化，可选.  </p><p>activity_regularizer: 输出的正则化函数.  </p><p>trainable: Boolean型，表明该层的参数是否参与训练。如果为真则变量加入到图集合中 GraphKeys.TRAINABLE_VARIABLES (see tf.Variable).  </p><p>name: 层的名字. </p><p>reuse: Boolean型, 是否重复使用参数.</p><p>tf.Session相当于一个指针，指针指着什么，就能查看什么或者使哪一个运行起来。</p><p>tf.placeholder 占位符，输入变量暂存的地方。</p><p>tf.feed_dict 字典填充函数，使输入输出变得简单</p><p><img src="d.png" alt=""></p><p>cross_entropy 交叉熵，用来衡量人工神经网络ANN的预测值与实际值的一种方式。</p><p>交叉熵代价函数：<img src="e.jpg" alt=""></p><p><img src="f.jpg" alt=""></p><p><img src="g.jpg" alt=""></p><p>好吧没看懂，总之训练效果比二次代价函数要好。完毕！</p><p>as for training model, we need to do three things first</p><ul><li><p>A <em>loss function</em>, which measures how well a given polynomial fits the data. The lower the loss value, the better the polynomial fits the data.</p></li><li><p>An <em>optimizer</em>, which implements an algorithm for revising our coefficient values based on the output of the loss function. The optimizer’s goal is to minimize the output value of the loss function.</p></li><li><p>A <em>training loop</em>, which will iteratively run the optimizer to minimize loss.</p></li></ul><p>  minimize最神奇的地方，自动调整参数诶，哇哦</p><p><img src="C:\Users\18749\AppData\Local\Temp\1535707394705.png" alt="1535707394705"></p><p>TensorBoard读取并展示日志</p><p>tensorboard –logdir = 日志所在路径</p><p>搭建神经网络：</p><p>1.构建数据</p><p>2.构建模型</p><p>3.构建loss函数</p><p>4.构建优化器opt 一般用tf.train.GradientDescentOptimizer(learn rate)</p><p>5.train = opt.minimize(loss)</p><p>6.构建会话sess=tf.Session() 并初始化变量</p><p>7.每一次训练都需要减小化loss    sess.run(opt.minimize(loss))  此处的minimize很神奇，自动去调节权重和偏差。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;参考资料：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原博客链接：&lt;a href=&quot;https://www.jianshu.com/p/d9ab35b56ab8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.
      
    
    </summary>
    
    
      <category term="TensorFlow" scheme="http://yoursite.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>matlab 常用函数使用及示例</title>
    <link href="http://yoursite.com/2018/08/26/matlab-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%A4%BA%E4%BE%8B/"/>
    <id>http://yoursite.com/2018/08/26/matlab-常用函数使用及示例/</id>
    <published>2018-08-26T10:42:55.000Z</published>
    <updated>2018-08-26T15:26:13.031Z</updated>
    
    <content type="html"><![CDATA[<p>注：matlab中所有的表达式都需要写成&lt;=的形式再带入。</p><p>解决线性问题常用函数 linprog  用法</p><p><img src="a.png" alt=""></p><p><img src="b.png" alt=""></p><p><img src="c.png" alt=""></p><p><img src="d.png" alt=""></p><p>结果</p><p><img src="e.png" alt=""></p><p>matlab一维差值 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注：matlab中所有的表达式都需要写成&amp;lt;=的形式再带入。&lt;/p&gt;
&lt;p&gt;解决线性问题常用函数 linprog  用法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;a.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;b.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;im
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数学建模</title>
    <link href="http://yoursite.com/2018/08/24/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    <id>http://yoursite.com/2018/08/24/数学建模/</id>
    <published>2018-08-24T02:32:25.000Z</published>
    <updated>2018-08-24T10:28:06.616Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：写论文做了什么事情，采用何种方法，解决了什么问题，得到了什么结果。问题1,2,3分开写。忌讳：1.背景说了一大堆。2.用matlab什么函数balabala！</p><p>问题重述：不能简单抄问题。把原来的问题，用自己的话描述，话语倾向于用何种方法解决，有侧重。一定要有！</p><p>做两件事情：1.构建数学模型。2.拟合。</p><p>最小二乘法：处理大批量离散的数据。</p><p>插值：经过所有的数据点，少量数据适用。低次、多元函数。</p><p>拟合：大量数据适用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;摘要：写论文做了什么事情，采用何种方法，解决了什么问题，得到了什么结果。问题1,2,3分开写。忌讳：1.背景说了一大堆。2.用matlab什么函数balabala！&lt;/p&gt;
&lt;p&gt;问题重述：不能简单抄问题。把原来的问题，用自己的话描述，话语倾向于用何种方法解决，有侧重。一定
      
    
    </summary>
    
    
      <category term="数学建模" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>程序静态连接、动态链接</title>
    <link href="http://yoursite.com/2018/08/23/%E7%A8%8B%E5%BA%8F%E9%9D%99%E6%80%81%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/08/23/程序静态连接、动态链接/</id>
    <published>2018-08-23T10:22:09.000Z</published>
    <updated>2018-08-23T11:59:21.161Z</updated>
    
    <content type="html"><![CDATA[<p>源代码到可执行文件过程：预编译（生成.i。处理源代码中以#开始的u、预编译指令，展开宏定义，删注释，递归包含头文件，加行号和文件名标识。详见P39），编译（生成.s。将预编译文件进行词法、语法、语义分析，优化生成汇编代码），汇编（生成.o。将汇编代码转换成机器可执行指令），链接（多个不同的目标文件之间相互粘到一起）。</p><p>静态链接：</p><p>所有的程序模块都链接成一个单独的可执行文件。由链接器在链接时将库的内容加入到可执行程序中的做法。浪费空间。是程序用一个链接一个，不知道共享的那种。发布时也会引入不同版本的操作系统需编写不同的链接程序。</p><p>动态链接：</p><p>程序的模块分隔成独立的文件，等程序要运行的时候才链接。链接过程推迟到运行时刻。有共享对象（linux：.so  windows：.dll）。延迟绑定。下面是例子</p><p>源代码如下，需要四个文件 Lib.c Lib.h Program1.c Program2.c</p><p><img src="a.png" alt=""></p><p><img src="b.png" alt=""></p><p>通过如下指令生成Lib.so共享对象</p><p><img src="c.png" alt=""></p><p>编译Program1.c和Program2.c</p><p><img src="d.png" alt=""></p><p>Program1的编译链接过程</p><p><img src="e.png" alt="编译和链接过程"></p><p>静态链接时，这一步会把Program1.o和Lib.o链接到一起，产生输出可执行文件Program1.</p><p>动态链接时，Lib.o没有链接进来，链接的输入目标文件只有Program1.o  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源代码到可执行文件过程：预编译（生成.i。处理源代码中以#开始的u、预编译指令，展开宏定义，删注释，递归包含头文件，加行号和文件名标识。详见P39），编译（生成.s。将预编译文件进行词法、语法、语义分析，优化生成汇编代码），汇编（生成.o。将汇编代码转换成机器可执行指令），
      
    
    </summary>
    
    
      <category term="装载" scheme="http://yoursite.com/tags/%E8%A3%85%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Longest Palindromic Substring题解</title>
    <link href="http://yoursite.com/2018/08/22/LeetCode-Longest-Palindromic-Substring%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/08/22/LeetCode-Longest-Palindromic-Substring题解/</id>
    <published>2018-08-22T12:04:12.000Z</published>
    <updated>2018-08-22T12:13:09.369Z</updated>
    
    <content type="html"><![CDATA[<p>思考这个问题，最初的想法是把所有的解都尝试一遍，然后找出最长的回文字符串，于是，我就用了递归，跑了一遍最初的实例，跑通了，然后很开心的去提交。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionLongestPalindromicSubstring</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindromic</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=s.length();</span><br><span class="line">        <span class="keyword">int</span> pl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pr=length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pl&lt;pr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.at(pl)!=s.at(pr))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pl++;</span><br><span class="line">            pr--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length=s.length();</span><br><span class="line">        <span class="keyword">int</span> pl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pr=length;</span><br><span class="line">        <span class="keyword">if</span> (pr&gt;=pl&amp;&amp;isPalindromic(s.substr(pl,(pr-pl))))&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> currpl=pl;</span><br><span class="line">        <span class="keyword">int</span> currpr=pr;</span><br><span class="line">        <span class="built_in">string</span> max=<span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>((++currpl)&lt;=pr)&#123;</span><br><span class="line">            temp=max=longestPalindrome(s.substr(currpl,currpr-currpl));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.length()&gt;max.length())</span><br><span class="line">            max=temp;</span><br><span class="line">        currpl=pl;</span><br><span class="line">        currpr=pr;</span><br><span class="line">        <span class="keyword">if</span>((--currpr)&gt;=currpl)&#123;</span><br><span class="line">            temp=longestPalindrome(s.substr(currpl,currpr-currpl));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.length()&gt;max.length())</span><br><span class="line">            max=temp;</span><br><span class="line">        currpl=pl+<span class="number">1</span>;</span><br><span class="line">        currpr=pr<span class="number">-1</span>;</span><br><span class="line">        temp=longestPalindrome(s.substr(currpl,currpr-currpl));</span><br><span class="line">        <span class="keyword">if</span>(temp.length()&gt;max.length())</span><br><span class="line">            max=temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结果，哦吼，超时了。</p><p>是啊，递归的复杂度太高了，然后，如果是我，肯定是从大的开始找啊。</p><p>顺着这个思路，再加上子串肯定是连续的，这么一想，然后就自动的去捆绑子串。</p><p>首先捆绑的子串的长度就是原串本身，如果是回文，则最长的子串就找到啦。</p><p>如果捆绑串不是回文，则捆绑的长度-1，再从左往右移动，依次检验当前捆绑串是否是回文子串</p><p>重复上诉步骤，肯定能找到回文串，毕竟一个字符也是回文子串嘛</p><p>贴代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionLongestPalindromicSubstring</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindromic</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=s.length();</span><br><span class="line">        <span class="keyword">int</span> pl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pr=length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pl&lt;pr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.at(pl)!=s.at(pr))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pl++;</span><br><span class="line">            pr--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPalindromic(s))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxLength=s.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> length=s.length();</span><br><span class="line">        <span class="keyword">int</span> pl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (maxLength&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span> (pl+maxLength&lt;=length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isPalindromic(s.substr(pl,maxLength)))&#123;</span><br><span class="line">                    <span class="keyword">return</span> s.substr(pl,maxLength);</span><br><span class="line">                &#125;</span><br><span class="line">                pl++;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLength--;</span><br><span class="line">            pl=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码地址:</p><p><a href="https://github.com/DuWenLi-mumu/LeetCodeSolution/blob/master/Longest%20Palindromic%20Substring.cpp" target="_blank" rel="noopener">https://github.com/DuWenLi-mumu/LeetCodeSolution/blob/master/Longest%20Palindromic%20Substring.cpp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;思考这个问题，最初的想法是把所有的解都尝试一遍，然后找出最长的回文字符串，于是，我就用了递归，跑了一遍最初的实例，跑通了，然后很开心的去提交。&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>木木的日常--注册账号</title>
    <link href="http://yoursite.com/2018/08/22/%E6%9C%A8%E6%9C%A8%E7%9A%84%E6%97%A5%E5%B8%B8-%E6%B3%A8%E5%86%8C%E8%B4%A6%E5%8F%B7/"/>
    <id>http://yoursite.com/2018/08/22/木木的日常-注册账号/</id>
    <published>2018-08-22T09:34:16.000Z</published>
    <updated>2018-08-22T12:01:45.211Z</updated>
    
    <content type="html"><![CDATA[<p>昨天，浏览了一下Tuts 4 You 也就是这个网站 <a href="https://tuts4you.com/" target="_blank" rel="noopener">https://tuts4you.com/</a><br>虽然不怎么看得懂，但发现里面好像有很多资源可以下载，于是就想，那就注册个账号嘛，多简单的事情！<br>然后，就开始了我的注册账号之旅，这可以说是我最难的一次注册账号的经历！<br>填好了基本信息，然后发现了一个搞笑的问题<br><img src="/2018/08/22/木木的日常-注册账号/a.jpg" title="figure1"><br>额，好吧，白活二十年！<br>接下来，下面这个问题，直接蒙了<br><img src="/2018/08/22/木木的日常-注册账号/b.jpg" title="figure2"><br>这是啥玩意儿，搜索了一下，原来是八进制的字符串匹配，噗，本来还想一个一个手工匹配，刚刚开始就放弃了。。。<br>算了，还是写个程序吧，，，<br>然后就开始了疯狂的复制粘贴匹配段之旅<br><img src="/2018/08/22/木木的日常-注册账号/c.jpg" title="figure3"><br>最后这段是什么意思呢？？？<br>程序运行出来是这样的<br><img src="/2018/08/22/木木的日常-注册账号/d.jpg" title="figure4"><br>噗 我TM还是不知道是什么意思，还是选择继续百度<br>百度结果如下，无果，切换成google<br><img src="/2018/08/22/木木的日常-注册账号/e.jpg" title="figure5"><br>google果然更好用，找到答案了<br><img src="/2018/08/22/木木的日常-注册账号/f.jpg" title="figure6"><br>噗，赶紧填进去，，，终于<br>注册成功了<br>其实中间还有选择下列图片中哪些是车，哪些是路，选错重来。<br>噗，直接崩溃，还好TM是写的程序，不然，，，，凭借我的耐心，我是别想注册账号了<br>登陆看看<br><img src="/2018/08/22/木木的日常-注册账号/g.jpg" title="figure7"></p><p>以后会经常浏览这个网站，这可是我花了一个多小时才注册的账号啊！！！！嘤嘤嘤！！！<br>代码地址:</p><p><a href="https://github.com/DuWenLi-mumu/CPlusPlusLearn/blob/master/decode8system.cpp" target="_blank" rel="noopener">https://github.com/DuWenLi-mumu/CPlusPlusLearn/blob/master/decode8system.cpp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天，浏览了一下Tuts 4 You 也就是这个网站 &lt;a href=&quot;https://tuts4you.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tuts4you.com/&lt;/a&gt;&lt;br&gt;虽然不怎么看得懂，但发现里面好像有很
      
    
    </summary>
    
    
      <category term="木木的日常" scheme="http://yoursite.com/tags/%E6%9C%A8%E6%9C%A8%E7%9A%84%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>my-first-blog</title>
    <link href="http://yoursite.com/2018/08/19/my-first-blog/"/>
    <id>http://yoursite.com/2018/08/19/my-first-blog/</id>
    <published>2018-08-19T11:23:23.000Z</published>
    <updated>2018-08-22T08:14:09.220Z</updated>
    
    <content type="html"><![CDATA[<p>木木的第一篇博客<br>额。。。。怎么说呢，欢迎来到木木的小屋！<br>哈哈哈！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;木木的第一篇博客&lt;br&gt;额。。。。怎么说呢，欢迎来到木木的小屋！&lt;br&gt;哈哈哈！&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="just for fun" scheme="http://yoursite.com/tags/just-for-fun/"/>
    
  </entry>
  
</feed>
